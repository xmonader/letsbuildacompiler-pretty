<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unit Construction - Let&#x27;s Build a Compiler</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About this project</a></li><li class="chapter-item expanded "><a href="tutor01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tutor02_expressionparsing.html"><strong aria-hidden="true">2.</strong> Expression Parsing</a></li><li class="chapter-item expanded "><a href="tutor03_moreexpressions.html"><strong aria-hidden="true">3.</strong> More Expressions</a></li><li class="chapter-item expanded "><a href="tutor04_interpreters.html"><strong aria-hidden="true">4.</strong> Interpreters</a></li><li class="chapter-item expanded "><a href="tutor05_controlstructs.html"><strong aria-hidden="true">5.</strong> Control Constructs</a></li><li class="chapter-item expanded "><a href="tutor06_booleanexpressions.html"><strong aria-hidden="true">6.</strong> Boolean Expressions</a></li><li class="chapter-item expanded "><a href="tutor07_lexicalscanning.html"><strong aria-hidden="true">7.</strong> Lexical Scanning</a></li><li class="chapter-item expanded "><a href="tutor08_littlephilosophy.html"><strong aria-hidden="true">8.</strong> A Little Philosophy</a></li><li class="chapter-item expanded "><a href="tutor09_atopview.html"><strong aria-hidden="true">9.</strong> A Top View</a></li><li class="chapter-item expanded "><a href="tutor10_introducingtiny.html"><strong aria-hidden="true">10.</strong> Introducing Tiny</a></li><li class="chapter-item expanded "><a href="tutor11_lexicalscanrevisited.html"><strong aria-hidden="true">11.</strong> Lexical Scan Revisited</a></li><li class="chapter-item expanded "><a href="tutor12_miscellany.html"><strong aria-hidden="true">12.</strong> Miscellany</a></li><li class="chapter-item expanded "><a href="tutor13_procedures.html"><strong aria-hidden="true">13.</strong> Procedures</a></li><li class="chapter-item expanded "><a href="tutor14_types.html"><strong aria-hidden="true">14.</strong> Types</a></li><li class="chapter-item expanded "><a href="tutor15_backtothefuture.html"><strong aria-hidden="true">15.</strong> Back to the Future</a></li><li class="chapter-item expanded "><a href="tutor16_unitconstruction.html" class="active"><strong aria-hidden="true">16.</strong> Unit Construction</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Let&#x27;s Build a Compiler</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/xmonader/letsbuildacompiler-pretty" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="part-xvi-unit-construction---29-may-1995"><a class="header" href="#part-xvi-unit-construction---29-may-1995">Part XVI: Unit Construction - 29 May 1995</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This series of tutorials promises to be perhaps one of the longest-running
mini-series in history, rivalled only by the delay in Volume IV
of Knuth.  Begun in 1988, the series ran into a four-year hiatus in 1990
when the “cares of this world,” changes in priorities and interests, and
the need to make a living seemed to stall it out after <a href="tutor14_types.html">Installment 14</a>.
Those of you with loads of patience were finally rewarded, in the spring
of last year, with the long-awaited <a href="tutor15_backtothefuture.html">Installment 15</a>.  In it, I began to
try to steer the series back on track, and in the process, to make it
easier to continue on to the goal, which is to provide you with not only
enough understanding of the difficult subject of compiler theory, but
also enough tools, in the form of canned subroutines and concepts, so
that you would be able to continue on your own and become proficient
enough to build your own parsers and translators.  Because of that long
hiatus, I thought it appropriate to go back and review the concepts we
have covered so far, and to redo some of the software, as well.  In the
past, we’ve never concerned ourselves much with the development of
production-quality software tools … after all, I was trying to teach
(and learn) concepts, not production practice.  To do that, I tended to
give you, not complete compilers or parsers, but only those snippets of
code that illustrated the particular point we were considering at the
moment.</p>
<p>I still believe that’s a good way to learn any subject; no one wants to
have to make changes to 100,000 line programs just to try out a new
idea.  But the idea of just dealing with code snippets, rather than
complete programs, also has its drawbacks in that we often seemed to be
writing the same code fragments over and over.  Although repetition has
been thoroughly proven to be a good way to learn new ideas, it’s also
true that one can have too much of a good thing.  By the time I had
completed Installment 14 I seemed to have reached the limits of my
abilities to juggle multiple files and multiple versions of the same
software functions.  Who knows, perhaps that’s one reason I seemed to
have run out of gas at that point.</p>
<p>Fortunately, the later versions of Borland’s Turbo Pascal allow us to
have our cake and eat it too.  By using their concept of separately
compilable units, we can still write small subroutines and functions,
and keep our main programs and test programs small and simple.  But,
once written, the code in the Pascal units will always be there for us
to use, and linking them in is totally painless and transparent.</p>
<p>Since, by now, most of you are programming in either C or C++, I know
what you’re thinking:  Borland, with their Turbo Pascal (TP), certainly
didn’t invent the concept of separately compilable modules.  And of
course you’re right.  But if you’ve not used TP lately, or ever, you may
not realize just how painless the whole process is.  Even in C or C++,
you still have to build a make file, either manually or by telling the
compiler how to do so.  You must also list, using <code>extern</code> statements or
header files, the functions you want to import.  In TP, you don’t even
have to do that.  You need only name the units you wish to use, and all
of their procedures automatically become available.</p>
<p>It’s not my intention to get into a language-war debate here, so I won’t
pursue the subject any further.  Even I no longer use Pascal on my job
… I use C at work and C++ for my articles in Embedded Systems
Programming and other magazines.  Believe me, when I set out to
resurrect this series, I thought long and hard about switching both
languages and target systems to the ones that we’re all using these
days, C/C++ and PC architecture, and possibly object-oriented methods as
well.  In the end, I felt it would cause more confusion than the hiatus
itself has. And after all, Pascal still remains one of the best possible
languages for teaching, not to mention production programming.  Finally,
TP still compiles at the speed of light, much faster than competing
C/C++ compilers. And Borland’s smart linker, used in TP but not in their
C++ products, is second to none.  Aside from being much faster than
Microsoft-compatible linkers, the Borland smart linker will cull unused
procedures and data items, even to the extent of trimming them out of
defined objects if they’re not needed.  For one of the few times in our
lives, we don’t have to compromise between completeness and efficiency.
When we’re writing a TP unit, we can make it as complete as we like,
including any member functions and data items we may think we will ever
need, confident that doing so will not create unwanted bloat in the
compiled and linked executable.</p>
<p>The point, really, is simply this:  By using TP’s unit mechanism, we can
have all the advantages and convenience of writing small, seemingly
stand-alone test programs, without having to constantly rewrite the
support functions that we need.  Once written, the TP units sit there,
quietly waiting to do their duty and give us the support we need, when
we need it.</p>
<p>Using this principle, in <a href="tutor15_backtothefuture.html">Installment 15</a> I set out to minimize our
tendency to re-invent the wheel by organizing  our code into separate
Turbo Pascal units, each containing different parts of the compiler.  We
ended up with the following units:</p>
<ul>
<li><code>Input</code></li>
<li><code>Output</code></li>
<li><code>Errors</code></li>
<li><code>Scanner</code></li>
<li><code>Parser</code></li>
<li><code>CodeGen</code></li>
</ul>
<p>Each of these units serves a different function, and encapsulates
specific areas of functionality.  The <code>Input</code> and <code>Output</code> units, as their
name implies, provide character stream I/O and the all-important
lookahead character upon which our predictive parser is based.  The
Errors unit, of course, provides standard error handling.  The Scanner
unit contains all of our boolean functions such as <code>IsAlpha</code>, and the
routines <code>GetName</code> and <code>GetNumber</code>, which process multi-character tokens.</p>
<p>The two units we’ll be working with the most, and the ones that most
represent the personality of our compiler, are Parser and CodeGen.
Theoretically, the <code>Parser</code> unit should encapsulate all aspects of the
compiler that depend on the syntax of the compiled language (though, as
we saw last time, a small amount of this syntax spills over into
<code>Scanner</code>).  Similarly, the code generator unit, <code>CodeGen</code>, contains all of
the code dependent upon the target machine.  In this installment, we’ll
be continuing with the development of the functions in these two
all-important units.</p>
<h2 id="just-like-classical"><a class="header" href="#just-like-classical">Just Like Classical?</a></h2>
<p>Before we proceed, however, I think I should clarify the relationship
between, and the functionality of these units.  Those of you who are
familiar with compiler theory as taught in universities will, of course,
recognize the names, Scanner, Parser, and CodeGen, all of which are
components of a classical compiler implementation.  You may be thinking
that I’ve abandoned my commitment to the KISS philosophy, and drifted
towards a more conventional architecture than we once had.  A closer
look, however, should convince you that, while the names are similar,
the functionalities are quite different.</p>
<p>Together, the scanner and parser of a classical implementation comprise
the so-called “front end,” and the code generator, the back end.  The
front end routines process the language-dependent, syntax-related
aspects of the source language, while the code generator, or back end,
deals with the target machine-dependent parts of the problem.  In
classical compilers, the two ends communicate via a file of instructions
written in an intermediate language (IL).</p>
<p>Typically, a classical scanner is a single procedure, operating as a
co-procedure with the parser.  It “tokenizes” the source file, reading
it character by character, recognizing language elements, translating
them into tokens, and passing them along to the parser.  You can think
of the parser as an abstract machine, executing “op codes,” which are
the tokens.  Similarly, the parser generates op codes of a second
abstract machine, which mechanizes the IL.  Typically, the IL file is
written to disk by the parser, and read back again by the code
generator.</p>
<p>Our organization is quite different.  We have no lexical scanner, in the
classical sense;  our unit <code>Scanner</code>, though it has a similar name, is not
a single procedure or co-procedure, but merely a set of separate
subroutines which are called by the parser as needed.</p>
<p>Similarly, the classical code generator, the back end,  is a translator
in its own right, reading an IL “source” file, and emitting an object
file.  Our code generator doesn’t work that way.  In our compiler, there
IS no intermediate language; every construct in the source language
syntax is converted into assembly language as it is recognized by the
parser.  Like Scanner, the unit <code>CodeGen</code> consists of individual
procedures which are called by the parser as needed.</p>
<p>This “code ’em as you find ’em” philosophy may not produce the world’s
most efficient code – for example, we haven’t provided (yet!) a
convenient place for an optimizer to work its magic – but it sure does
simplify the compiler, doesn’t it?</p>
<p>And that observation prompts me to reflect, once again, on how we have
managed to reduce a compiler’s functions to such comparatively simple
terms.  I’ve waxed eloquent on this subject in past installments, so I
won’t belabor the point too much here.  However, because of the time
that’s elapsed since those last soliloquies, I hope you’ll grant me just
a little time to remind myself, as well as you, how we got here.  We got
here by applying several principles that writers of commercial compilers
seldom have the luxury of using.  These are:</p>
<ul>
<li>The KISS philosophy: Never do things the hard way without a
reason</li>
<li>Lazy coding: Never put off until tomorrow what you can put
of forever (with credits to P.J. Plauger)</li>
<li>Skepticism: Stubborn refusal to do something just because
that’s the way it’s always been done.</li>
<li>Acceptance of inefficient code</li>
<li>Rejection of arbitrary constraints</li>
</ul>
<p>As I’ve reviewed the history of compiler construction, I’ve learned that
virtually every production compiler in history has suffered from
pre-imposed conditions that strongly influenced its design. The original
FORTRAN compiler of John Backus, et al, had to compete with assembly
language, and therefore was constrained to produce extremely efficient
code.  The IBM compilers for the minicomputers of the 70’s had to run in
the very small RAM memories then available – as small as 4k.  The early
Ada compiler had to compile itself.  Per Brinch Hansen decreed that his
Pascal compiler developed for the IBM PC must execute in a 64k machine.
Compilers developed in Computer Science courses had to compile the
widest variety of languages, and therefore required LALR parsers.</p>
<p>In each of these cases, these preconceived constraints literally
dominated the design of the compiler.</p>
<p>A good example is Brinch Hansen’s compiler, described in his excellent
book, “Brinch Hansen on Pascal Compilers” (highly recommended).  Though
his compiler is one of the most clear and un-obscure compiler
implementations I’ve seen, that one decision, to compile large files in
a small RAM, totally drives the design, and he ends up with not just
one, but many intermediate files, together with the drivers to write and
read them.</p>
<p>In time, the architectures resulting from such decisions have found
their way into computer science lore as articles of faith. In this one
man’s opinion, it’s time that they were re-examined critically.  The
conditions, environments, and requirements that led to classical
architectures are not the same as the ones we have today.  There’s no
reason to believe the solutions should be the same, either.</p>
<p>In this tutorial, we’ve followed the leads of such pioneers in the world
of small compilers for Pcs as Leor Zolman, Ron Cain, and James Hendrix,
who didn’t know enough compiler theory to know that they “couldn’t do it
that way.”  We have resolutely refused to accept arbitrary constraints,
but rather have done whatever was easy.  As a result, we have evolved an
architecture that, while quite different from the classical one, gets
the job done in very simple and straightforward fashion.</p>
<p>I’ll end this philosophizing with an observation re the notion of an
intermediate language.  While I’ve noted before that we don’t have one
in our compiler, that’s not exactly true; we <em>do</em> have one, or at least
are evolving one, in the sense that we are defining code generation
functions for the parser to call.  In essence, every call to a code
generation procedure can be thought of as an instruction in an
intermediate language.  Should we ever find it necessary to formalize an
intermediate language, this is the way we would do it:  emit codes from
the parser, each representing a call to one of the code generator
procedures, and then process each code by calling those procedures in a
separate pass, implemented in a back end. Frankly, I don’t see that
we’ll ever find a need for this approach, but there is the connection,
if you choose to follow it, between the classical and the current
approaches.</p>
<h2 id="fleshing-out-the-parser"><a class="header" href="#fleshing-out-the-parser">Fleshing out the Parser</a></h2>
<p>Though I promised you, somewhere along about <a href="tutor14_types.html">Installment 14</a>, that we’d
never again write every single function from scratch, I ended up
starting to do just that in <a href="tutor15_backtothefuture.html">Installment 15</a>.  One reason: that long
hiatus between the two installments made a review seem eminently
justified … even imperative, both for you and for me. More
importantly, the decision to collect the procedures into modules
(units), forced us to look at each one yet again, whether we wanted to
or not.  And, finally and frankly, I’ve had some new ideas in the last
four years that warranted a fresh look at some old friends.  When I
first began this series, I was frankly amazed, and pleased, to learn
just how simple parsing routines can be made.  But this last time
around, I’ve surprised myself yet again, and been able to make them just
that last little bit simpler, yet.</p>
<p>Still, because of this total rewrite of the parsing modules, I was only
able to include so much in the last installment.  Because of this, our
hero, the parser, when last seen, was a shadow of its former self,
consisting of only enough code to parse and process a factor consisting
of either a variable or a constant.  The main effort of this current
installment will be to help flesh out the parser to its former glory.
In the process, I hope you’ll bear with me if we sometimes cover ground
we’ve long since been over and dealt with.</p>
<p>First, let’s take care of a problem that we’ve addressed before: Our
current version of procedure <code>Factor</code>, as we left it in Installment 15,
can’t handle negative arguments.  To fix that, we’ll introduce the
procedure <code>SignedFactor</code>:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Parse and Translate a Factor with Optional Sign }

procedure SignedFactor;
var Sign: char;
begin
	Sign := Look;
	if IsAddop(Look) then
		GetChar;
	Factor;
	if Sign = '-' then Negate;
end;
{--------------------------------------------------------------}
</code></pre>
<p>Note that this procedure calls a new code generation routine, <code>Negate</code>:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Negate Primary }

procedure Negate;
begin
	EmitLn('NEG D0');
end;
{--------------------------------------------------------------}
</code></pre>
<p>(Here, and elsewhere in this series, I’m only going to show you the new
routines. I’m counting on you to put them into the proper unit, which
you should normally have no trouble identifying.  Don’t forget to add
the procedure’s prototype to the interface section of the unit.)</p>
<p>In the main program, simply change the procedure called from <code>Factor</code> to
<code>SignedFactor</code>, and give the code a test.  Isn’t it neat how the Turbo
linker and make facility handle all the details?</p>
<p>Yes, I know, the code isn’t very efficient.  If we input a number, <code>-3</code>,
the generated code is:</p>
<pre><code class="language-asm">MOVE #3,D0
NEG D0
</code></pre>
<p>which is really, really dumb.  We can do better, of course, by simply
pre-appending a minus sign to the string passed to <code>LoadConstant</code>, but it
adds a few lines of code to <code>SignedFactor</code>, and I’m applying the KISS
philosophy very aggressively here. What’s more,  to tell the truth, I
think I’m subconsciously enjoying generating “really, really dumb” code,
so I can have the pleasure of watching it get dramatically better when
we get into optimization methods.</p>
<p>Most of you have never heard of John Spray, so allow me to introduce him
to you here.  John’s from New Zealand, and used to teach computer
science at one of its universities.  John wrote a compiler for the
Motorola 6809, based on a delightful, Pascal-like language of his own
design called “Whimsical.”  He later ported the compiler to the 68000,
and for awhile it was the only compiler I had for my homebrewed 68000
system.</p>
<p>For the record, one of my standard tests for any new compiler is to see
how the compiler deals with a null program like:</p>
<pre><code>program main;
begin
end.
</code></pre>
<p>My test is to measure the time required to compile and link, and the
size of the object file generated.  The undisputed <em>loser</em> in the test
is the DEC C compiler for the VAX, which took 60 seconds to compile, on
a VAX 11/780, and generated a 50k object file.  John’s compiler is the
undisputed, once, future, and forever king in the code size department.
Given the null program, Whimsical generates precisely two bytes of code,
implementing the one instruction, <code>RET</code>.</p>
<p>By setting a compiler option to generate an include file rather than a
standalone program, John can even cut this size, from two bytes to zero!
Sort of hard to beat a null object file, wouldn’t you say?</p>
<p>Needless to say, I consider John to be something of an expert on code
optimization, and I like what he has to say: “The best way to optimize
is not to have to optimize at all, but to produce good code in the first
place.” Words to live by.  When we get started on optimization, we’ll
follow John’s advice, and our first step will not be to add a peephole
optimizer or other after-the-fact device, but to improve the quality of
the code emitted before optimization.  So make a note of <code>SignedFactor</code> as
a good first candidate for attention, and for now we’ll leave it be.</p>
<h2 id="terms-and-expressions"><a class="header" href="#terms-and-expressions">Terms and Expressions</a></h2>
<p>I’m sure you know what’s coming next: We must, yet again, create the
rest of the procedures that implement the recursive-descent parsing of
an expression.  We all know that the hierarchy of procedures for
arithmetic expressions is:</p>
<pre><code>expression
	term
		factor
</code></pre>
<p>However, for now let’s continue to do things one step at a time,
and consider only expressions with additive terms in them.  The
code to implement expressions, including a possibly signed first
term, is shown next:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Parse and Translate an Expression }

procedure Expression;
begin
	SignedFactor;
	while IsAddop(Look) do
		case Look of
			'+': Add;
			'-': Subtract;
		end;
end;
{--------------------------------------------------------------}
</code></pre>
<p>This procedure calls two other procedures to process the
operations:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Parse and Translate an Addition Operation }

procedure Add;
begin
	Match('+');
	Push;
	Factor;
	PopAdd;
end;


{--------------------------------------------------------------}
{ Parse and Translate a Subtraction Operation }

procedure Subtract;
begin
	Match('-');
	Push;
	Factor;
	PopSub;
end;
{--------------------------------------------------------------}
</code></pre>
<p>The three procedures <code>Push</code>, <code>PopAdd</code>, and <code>PopSub</code> are new code generation
routines.  As the name implies, procedure <code>Push</code> generates code to push
the primary register (<code>D0</code>, in our 68000 implementation) to the stack.
<code>PopAdd</code> and <code>PopSub</code> pop the top of the stack again, and add it to, or
subtract it from, the primary register.  The code is shown next:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Push Primary to Stack }

procedure Push;
begin
	EmitLn('MOVE D0,-(SP)');
end;

{--------------------------------------------------------------}
{ Add TOS to Primary }

procedure PopAdd;
begin
	EmitLn('ADD (SP)+,D0');
end;

{--------------------------------------------------------------}
{ Subtract TOS from Primary }

procedure PopSub;
begin
	EmitLn('SUB (SP)+,D0');
	Negate;
end;
{--------------------------------------------------------------}
</code></pre>
<p>Add these routines to <code>Parser</code> and <code>CodeGen</code>, and change the <code>main</code> program to
call <code>Expression</code>. Voila!</p>
<p>The next step, of course, is to add the capability for dealing with
multiplicative terms.  To that end, we’ll add a procedure <code>Term</code>, and code
generation procedures <code>PopMul</code> and <code>PopDiv</code>.  These code generation
procedures are shown next:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Multiply TOS by Primary }

procedure PopMul;
begin
	EmitLn('MULS (SP)+,D0');
end;

{--------------------------------------------------------------}
{ Divide Primary by TOS }

procedure PopDiv;
begin
	EmitLn('MOVE (SP)+,D7');
	EmitLn('EXT.L D7');
	EmitLn('DIVS D0,D7');
	EmitLn('MOVE D7,D0');
end;
{--------------------------------------------------------------}
</code></pre>
<p>I admit, the division routine is a little busy, but there’s no help for
it.  Unfortunately, while the 68000 CPU allows a division using the top
of stack (TOS), it wants the arguments in the wrong order, just as it
does for subtraction.  So our only recourse is to pop the stack to a
scratch register (<code>D7</code>), perform the division there, and then move the
result back to our primary register, <code>D0</code>. Note the use of signed multiply
and divide operations.  This follows an implied, but unstated,
assumption, that all our variables will be signed 16-bit integers. This
decision will come back to haunt us later, when we start looking at
multiple data types, type conversions, etc.</p>
<p>Our procedure <code>Term</code> is virtually a clone of <code>Expression</code>, and looks like
this:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Parse and Translate a Term }

procedure Term;
begin
	Factor;
	while IsMulop(Look) do
		case Look of
			'*': Multiply;
			'/': Divide;
		end;
end;
{--------------------------------------------------------------}
</code></pre>
<p>Our next step is to change some names.  <code>SignedFactor</code> now becomes
<code>SignedTerm</code>, and the calls to <code>Factor</code> in <code>Expression</code>, <code>Add</code>, <code>Subtract</code> and
<code>SignedTerm</code> get changed to call <code>Term</code>:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Parse and Translate a Term with Optional Leading Sign }

procedure SignedTerm;
var Sign: char;
begin
	Sign := Look;
	if IsAddop(Look) then
		GetChar;
	Term;
	if Sign = '-' then Negate;
end;
{--------------------------------------------------------------}
...
{--------------------------------------------------------------}
{ Parse and Translate an Expression }

procedure Expression;
begin
	SignedTerm;
	while IsAddop(Look) do
		case Look of
			'+': Add;
			'-': Subtract;
		end;
end;
{--------------------------------------------------------------}
</code></pre>
<p>If memory serves me correctly, we once had <em>both</em> a procedure <code>SignedFactor</code>
and a procedure <code>SignedTerm</code>. I had reasons for doing that at the time …
they had to do with the handling of Boolean algebra and, in particular,
the Boolean “not” function.  But certainly, for arithmetic operations,
that duplication isn’t necessary.  In an expression like <code>-x*y</code>,
it’s very apparent that the sign goes with the whole <em>term</em>, <code>x*y</code>, and not
just the factor <code>x</code>, and that’s the way <code>Expression</code> is coded.</p>
<p>Test this new code by executing <code>Main</code>.  It still calls <code>Expression</code>, so you
should now be able to deal with expressions containing any of the four
arithmetic operators.</p>
<p>Our last bit of business, as far as expressions goes, is to modify
procedure <code>Factor</code> to allow for parenthetical expressions.  By using a
recursive call to <code>Expression</code>, we can reduce the needed code to virtually
nothing.  Five lines added to <code>Factor</code> do the job:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Parse and Translate a Factor }

procedure Factor;
begin
	if Look ='(' then begin
		Match('(');
		Expression;
		Match(')');
		end
	else if IsDigit(Look) then
		LoadConstant(GetNumber)
	else if IsAlpha(Look)then
		LoadVariable(GetName)
	else
		Error('Unrecognized character ' + Look);
end;
{--------------------------------------------------------------}
</code></pre>
<p>At this point, your “compiler” should be able to handle any legal
expression you can throw at it.  Better yet, it should reject all
illegal ones!</p>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>As long as we’re this close, we might as well create the code to deal
with an assignment statement.  This code needs only to remember the name
of the target variable where we are to store the result of an
expression, call <code>Expression</code>, then store the number.  The procedure is
shown next:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Parse and Translate an Assignment Statement }

procedure Assignment;
var Name: string;
begin
	Name := GetName;
	Match('=');
	Expression;
	StoreVariable(Name);
end;
{--------------------------------------------------------------}
</code></pre>
<p>The assignment calls for yet another code generation routine:</p>
<pre><code class="language-delphi">
{--------------------------------------------------------------}
{ Store the Primary Register to a Variable }

procedure StoreVariable(Name: string);
begin
	EmitLn('LEA ' + Name + '(PC),A0');
	EmitLn('MOVE D0,(A0)');
end;
{--------------------------------------------------------------}
</code></pre>
<p>Now, change the call in <code>Main</code> to call <code>Assignment</code>, and you should see a
full assignment statement being processed correctly.  Pretty neat, eh?
And painless, too.</p>
<p>In the past, we’ve always tried to show BNF relations to define the
syntax we’re developing. I haven’t done that here, and it’s high time I
did.  Here’s the BNF:</p>
<pre><code class="language-bnf">&lt;factor&gt;      ::= &lt;variable&gt; | &lt;constant&gt; | '(' &lt;expression&gt; ')'
&lt;signed_term&gt; ::= [&lt;addop&gt;] &lt;term&gt;
&lt;term&gt;        ::= &lt;factor&gt; (&lt;mulop&gt; &lt;factor&gt;)*
&lt;expression&gt;  ::= &lt;signed_term&gt; (&lt;addop&gt; &lt;term&gt;)*
&lt;assignment&gt;  ::= &lt;variable&gt; '=' &lt;expression&gt;
</code></pre>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>The next step, as we’ve learned several times before, is to add Boolean
algebra.  In the past, this step has at least doubled the amount of code
we’ve had to write.  As I’ve gone over this step in my mind, I’ve found
myself diverging more and more from what we did in previous
installments.  To refresh your memory, I noted that Pascal treats the
Boolean operators pretty much identically to the way it treats
arithmetic ones.  A Boolean “and” has the same precedence level as
multiplication, and the “or” as addition.  C, on the other hand, sets
them at different precedence levels, and all told has a whopping 17
levels.  In our earlier work, I chose something in between, with seven
levels.  As a result, we ended up with things called Boolean
expressions, paralleling in most details the arithmetic expressions, but
at a different precedence level.  All of this, as it turned out, came
about because I didn’t like having to put parentheses around the Boolean
expressions in statements like
<code>IF (c &gt;= 'A') and (c &lt;= 'Z') then ...</code>.</p>
<p>In retrospect, that seems a pretty petty reason to add many layers of
complexity to the parser.  Perhaps more to the point, I’m not sure I was
even able to avoid the parens.</p>
<p>For kicks, let’s start anew, taking a more Pascal-ish approach, and just
treat the Boolean operators at the same precedence level as the
arithmetic ones. We’ll see where it leads us.  If it seems to be down
the garden path, we can always backtrack to the earlier approach.</p>
<p>For starters, we’ll add the “addition-level” operators to <code>Expression</code>.
That’s easily done; first, modify the function <code>IsAddop</code> in unit <code>Scanner</code>
to include two extra operators: <code>|</code> for “or,” and <code>~</code> for “exclusive
or”:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
function IsAddop(c: char): boolean;
begin
	IsAddop := c in ['+','-', '|', '~'];
end;
{--------------------------------------------------------------}
</code></pre>
<p>Next, we must include the parsing of the operators in procedure
<code>Expression</code>:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
procedure Expression;
begin
	SignedTerm;
	while IsAddop(Look) do
		case Look of
			'+': Add;
			'-': Subtract;
			'|': _Or;
			'~': _Xor;
		end;
{--------------------------------------------------------------}
end;
</code></pre>
<p>(The underscores are needed, of course, because <code>or</code> and <code>xor</code> are
reserved words in Turbo Pascal.)</p>
<p>Next, the procedures <code>_Or</code> and <code>_Xor</code>:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Parse and Translate a Subtraction Operation }

procedure _Or;
begin
	Match('|');
	Push;
	Term;
	PopOr;
end;

{--------------------------------------------------------------}
{ Parse and Translate a Subtraction Operation }

procedure _Xor;
begin
	Match('~');
	Push;
	Term;
	PopXor;
end;
{--------------------------------------------------------------}
</code></pre>
<p>And, finally, the new code generator procedures:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Or TOS with Primary }

procedure PopOr;
begin
	EmitLn('OR (SP)+,D0');
end;

{--------------------------------------------------------------}
{ Exclusive-Or TOS with Primary }

procedure PopXor;
begin
	EmitLn('EOR (SP)+,D0');
end;
{--------------------------------------------------------------}
</code></pre>
<p>Now, let’s test the translator (you might want to change the call
in <code>Main</code> back to a call to <code>Expression</code>, just to avoid having to type
<code>x=</code> for an assignment every time).</p>
<p>So far, so good.  The parser nicely handles expressions of the
form <code>x|y~z</code>.</p>
<p>Unfortunately, it also does nothing to protect us from mixing
Boolean and arithmetic algebra.  It will merrily generate code
for <code>(a+b)*(c~d)</code>.</p>
<p>We’ve talked about this a bit, in the past.  In general the rules
for what operations are legal or not cannot be enforced by the
parser itself, because they are not part of the syntax of the
language, but rather its semantics.  A compiler that doesn’t allow
mixed-mode expressions of this sort must recognize that c and d
are Boolean variables, rather than numeric ones, and balk at
multiplying them in the next step. But this “policing” can’t be
done by the parser; it must be handled somewhere between the
parser and the code generator. We aren’t in a position to enforce
such rules yet, because we haven’t got either a way of declaring
types, or a symbol table to store the types in.  So, for what
we’ve got to work with at the moment, the parser is doing
precisely what it’s supposed to do.</p>
<p>Anyway, are we sure that we <em>don’t</em> want to allow mixed-type
operations?  We made the decision some time ago (or, at least, I
did) to adopt the value <code>0000</code> as a Boolean <code>false</code>, and <code>-1</code>, or
<code>FFFFh</code>, as a Boolean <code>true</code>.  The nice part about this choice is
that bitwise operations work exactly the same way as logical ones.
In other words, when we do an operation on one bit of a logical
variable, we do it on all of them.  This means that we don’t need
to distinguish between logical and bitwise operations, as is done
in C with the operators <code>&amp;</code> and <code>&amp;&amp;,</code> and <code>|</code> and <code>||</code>.  Reducing the
number of operators by half certainly doesn’t seem all bad.</p>
<p>From the point of view of the data in storage, of course, the
computer and compiler couldn’t care less whether the number FFFFh
represents the logical <code>TRUE</code>, or the numeric <code>-1</code>.  Should we?  I
sort of think not.  I can think of many examples (though they
might be frowned upon as “tricky” code) where the ability to mix
the types might come in handy.  Example, the Dirac delta function,
which could be coded in one simple line, <code>-(x=0)</code>,
or the absolute value function (<em>definitely</em> tricky code!),
<code>x*(1+2*(x&lt;0))</code>.</p>
<p>Please note, I’m not advocating coding like this as a way of life.
I’d almost certainly write these functions in more readable form,
using <code>IF</code>s, just to keep from confusing later maintainers.  Still,
a moral question arises:  Do we have the right to <em>enforce</em> our
ideas of good coding practice on the programmer, but writing the
language so they can’t do anything else?  That’s what Nicklaus Wirth
did, in many places in Pascal, and Pascal has been criticized for
it – for not being as “forgiving” as C.</p>
<p>An interesting parallel presents itself in the example of the
Motorola 68000 design.  Though Motorola brags loudly about the
orthogonality of their instruction set, the fact is that it’s far
from orthogonal.  For example, you can read a variable from its
address:</p>
<pre><code class="language-asm">MOVE X,D0 (where X is the name of a variable)
</code></pre>
<p>but you can’t write in the same way.  To write, you must load an
address register with the address of <code>X</code>.  The same is true for
PC-relative addressing:</p>
<pre><code class="language-asm">MOVE X(PC),DO	(legal)
MOVE D0,X(PC)	(illegal)
</code></pre>
<p>When you begin asking how such non-orthogonal behavior came about,
you find that someone in Motorola had some theories about how
software should be written.  Specifically, in this case, they
decided that self-modifying code, which you can implement using
PC-relative writes, is a Bad Thing.  Therefore, they designed the
processor to prohibit it.  Unfortunately, in the process they also
prohibited <em>all</em> writes of the forms shown above, however benign.
Note that this was not something done by default.  Extra design
work had to be done, and extra gates added, to destroy the natural
orthogonality of the instruction set.</p>
<p>One of the lessons I’ve learned from life: If you have two
choices, and can’t decide which one to take, sometimes the best
thing to do is nothing.  Why add extra gates to a processor to
enforce some stranger’s idea of good programming practice?  Leave
the instructions in, and let the programmers debate what good
programming practice is.  Similarly, why should we add extra code
to our parser, to test for and prevent conditions that the user
might prefer to do, anyway?  I’d rather leave the compiler simple,
and let the software experts debate whether the practices should
be used or not.</p>
<p>All of which serves as rationalization for my decision as to how
to prevent mixed-type arithmetic:  I won’t.  For a language
intended for systems programming, the fewer rules, the better. If
you don’t agree, and want to test for such conditions, we can do
it once we have a symbol table.</p>
<h2 id="boolean-and"><a class="header" href="#boolean-and">Boolean “and”</a></h2>
<p>With that bit of philosophy out of the way, we can press on to the
“and” operator, which goes into procedure <code>Term</code>. By now, you can
probably do this without me, but here’s the code, anyway:</p>
<p>In <code>Scanner</code>,</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
function IsMulop(c: char): boolean;
begin
	IsMulop := c in ['*','/', '&amp;'];
end;
{--------------------------------------------------------------}
</code></pre>
<p>In <code>Parser</code>,</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
procedure Term;
begin
	Factor;
	while IsMulop(Look) do
		case Look of
			'*': Multiply;
			'/': Divide;
			'&amp;': _And;
		end;
end;

{--------------------------------------------------------------}
{ Parse and Translate a Boolean And Operation }

procedure _And;
begin
	Match('&amp;');
	Push;
	Factor;
	PopAnd;
end;
{--------------------------------------------------------------}
</code></pre>
<p>and in <code>CodeGen</code>,</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ And Primary with TOS }

procedure PopAnd;
begin
	EmitLn('AND (SP)+,D0');
end;
{--------------------------------------------------------------}
</code></pre>
<p>Your parser should now be able to process almost any sort of logical
expression, and (should you be so inclined), mixed-mode expressions as
well.</p>
<p>Why not “all sorts of logical expressions”?  Because, so far, we haven’t
dealt with the logical “not” operator, and this is where it gets tricky.
The logical “not” operator seems, at first glance, to be identical in
its behavior to the unary minus, so my first thought was to let the
exclusive or operator, <code>~</code>, double as the unary “not.”  That didn’t
work. In my first attempt, procedure <code>SignedTerm</code> simply ate my <code>~</code>,
because the character passed the test for an addop, but <code>SignedTerm</code>
ignores all addops except <code>-</code>.  It would have been easy enough to add
another line to <code>SignedTerm</code>, but that would still not solve the problem,
because note that <code>Expression</code> only accepts a signed term for the <em>first</em>
argument.</p>
<p>Mathematically, an expression like <code>-a * -b</code>
makes little or no sense, and the parser should flag it as an error.
But the same expression, using a logical “not,” makes perfect sense:
<code>not a and not b</code>.</p>
<p>In the case of these unary operators, choosing to make them act the same
way seems an artificial force fit, sacrificing reasonable behavior on
the altar of implementational ease.  While I’m all for keeping the
implementation as simple as possible, I don’t think we should do so at
the expense of reasonableness.  Patching like this would be missing the
main point, which is that the logical “not” is simply NOT the same kind
of animal as the unary minus.  Consider the exclusive or, which is most
naturally written as <code>a~b ::= (a and not b) or (not a and b)</code>.</p>
<p>If we allow the “not” to modify the whole term, the last term in
parentheses would be interpreted as <code>not(a and b)</code>.</p>
<p>which is not the same thing at all.  So it’s clear that the logical
“not” must be thought of as connected to the FACTOR, not the term.</p>
<p>The idea of overloading the <code>~</code> operator also makes no sense from a
mathematical point of view.  The implication of the unary minus is that
it’s equivalent to a subtraction from zero: <code>-x &lt;=&gt; 0-x</code>.</p>
<p>In fact, in one of my more simple-minded versions of <code>Expression</code>, I
reacted to a leading addop by simply preloading a zero, then processing
the operator as though it were a binary operator.  But a “not” is not
equivalent to an exclusive or with zero … that would just give back
the original number.  Instead, it’s an exclusive or with <code>FFFFh</code>, or <code>-1</code>.</p>
<p>In short, the seeming parallel between the unary “not” and the unary
minus falls apart under closer scrutiny. “not” modifies the factor, not
the term, and it is not related to either the unary minus nor the
exclusive or.  Therefore, it deserves a symbol to call its own. What
better symbol than the obvious one, also used by C, the <code>!</code> character?
Using the rules about the way we think the “not” should behave, we
should be able to code the exclusive or (assuming we’d ever need to), in
the very natural form: <code>a &amp; !b | !a &amp; b</code>.</p>
<p>Note that no parentheses are required – the precedence levels we’ve
chosen automatically take care of things.</p>
<p>If you’re keeping score on the precedence levels, this definition puts
the <code>!</code> at the top of the heap.  The levels become:</p>
<ol>
<li><code>!</code></li>
<li><code>-</code> (unary)</li>
<li><code>*</code>, <code>/</code>, <code>&amp;</code></li>
<li><code>+</code>, <code>-</code>, <code>|</code>, <code>~</code></li>
</ol>
<p>Looking at this list, it’s certainly not hard to see why we had trouble
using <code>~</code> as the “not” symbol!</p>
<p>So how do we mechanize the rules?  In the same way as we did with
<code>SignedTerm</code>, but at the factor level.  We’ll define a procedure
<code>NotFactor</code>:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Parse and Translate a Factor with Optional &quot;Not&quot; }

procedure NotFactor;
begin
	if Look ='!' then begin
		Match('!');
		Factor;
		Notit;
		end
	else
		Factor;
end;
{--------------------------------------------------------------}
</code></pre>
<p>and call it from all the places where we formerly called <code>Factor</code>, i.e.,
from <code>Term</code>, <code>Multiply</code>, <code>Divide</code>, and <code>_And</code>.  Note the new code generation
procedure:</p>
<pre><code class="language-delphi">{--------------------------------------------------------------}
{ Bitwise Not Primary }

procedure NotIt;
begin
	EmitLn('EOR #-1,D0');
end;

{--------------------------------------------------------------}
</code></pre>
<p>Try this now, with a few simple cases. In fact, try that exclusive or
example, <code>a&amp;!b|!a&amp;b</code>.</p>
<p>You should get the code (without the comments, of course):</p>
<pre><code class="language-asm">MOVE A(PC),DO		; load a
MOVE D0,-(SP)		; push it
MOVE B(PC),DO		; load b
EOR #-1,D0		; not it
AND (SP)+,D0		; and with a
MOVE D0,-(SP)		; push result
MOVE A(PC),DO		; load a
EOR #-1,D0		; not it
MOVE D0,-(SP)		; push it
MOVE B(PC),DO		; load b
AND (SP)+,D0		; and with !a
OR (SP)+,D0		; or with first term
</code></pre>
<p>That’s precisely what we’d like to get.  So, at least for both
arithmetic and logical operators, our new precedence and new, slimmer
syntax hang together.  Even the peculiar, but legal, expression with
leading addop, <code>~x</code>,
makes sense.  <code>SignedTerm</code> ignores the leading <code>~</code>, as it should, since
the expression is equivalent to <code>0~x</code>,
which is equal to x.</p>
<p>When we look at the BNF we’ve created, we find that our boolean algebra
now adds only one extra line:</p>
<pre><code class="language-bnf">&lt;not_factor&gt; 	::= [!] &lt;factor&gt;
&lt;factor&gt;      	::= &lt;variable&gt; | &lt;constant&gt; | '(' &lt;expression&gt; ')'
&lt;signed_term&gt; 	::= [&lt;addop&gt;] &lt;term&gt;
&lt;term&gt;        	::= &lt;not_factor&gt; (&lt;mulop&gt; &lt;not_factor&gt;)*
&lt;expression&gt;  	::= &lt;signed_term&gt; (&lt;addop&gt; &lt;term&gt;)*
&lt;assignment&gt;  	::= &lt;variable&gt; '=' &lt;expression&gt;
</code></pre>
<p>That’s a big improvement over earlier efforts.  Will our luck continue
to hold when we get to relational operators?  We’ll find out soon, but
it will have to wait for the next installment. We’re at a good stopping
place, and I’m anxious to get this installment into your hands.  It’s
already been a year since the release of <a href="tutor15_backtothefuture.html">Installment 15</a>.  I blush to
admit that all of this current installment has been ready for almost as
long, with the exception of relational operators.  But the information
does you no good at all, sitting on my hard disk, and by holding it back
until the relational operations were done, I’ve kept it out of your
hands for that long.  It’s time for me to let go of it and get it out
where you can get value from it. Besides, there are quite a number of
serious philosophical questions associated with the relational
operators, as well, and I’d rather save them for a separate installment
where I can do them justice.</p>
<p>Have fun with the new, leaner arithmetic and logical parsing, and I’ll
see you soon with relationals.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="tutor15_backtothefuture.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="tutor15_backtothefuture.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="highlight.js"></script>


    </div>
    </body>
</html>
